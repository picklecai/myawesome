# 正则表达式的用法  

别人的笔记：[可能是最好的正则表达式的教程笔记了吧... - 掘金](https://juejin.im/post/5b5db5b8e51d4519155720d2)  

[这可能是迄今最好的正则表达式语法测试教程学习笔记 - 神评(www.ishenping.com)](http://www.ishenping.com/ArtInfo/29302.html)

这里还有个在线测试工具：[在线正则表达式测试](http://tool.oschina.net/regex)

## 1. 匹配过程  

`import re`  

### 1.1 search方法  

从抽象字符串（匹配格式文本）到具体字符串（被匹配到的文本），一共经历三步🚶‍♀️🚶‍♀️🚶‍♀️：  
1. 抽象字符串（格式文本）输入`re.compile`做参数（`re.compile(r'Regex表达式')`，使用r是为了标识为原始字符串，方便\的出现。），输出Regex对象    
2. Regex对象调用search方法，使用查找池原始字符串做参数（`xxRegex.search(msg)`）。顺利的话，得到match对象，否则就是None（找不到对应格式的文本）  
3. Match对象调用group方法（`mo.group()`），无须参数，得到匹配的具体字符串。  

### 1.2 findall方法  

1. 第一步同上，抽象字符串（格式文本）输入`re.compile`做参数（`re.compile(r'Regex表达式')`，输出Regex对象   
2. 第二步， Regex对象调用findall方法，使用查找池原始字符串做参数（`xxRegex.findall(msg)`）。得到的不是match对象，而是匹配具体字符串组成的列表list。[matchtext1, matchtext2, ……，matchtextN]  
3. 要想得到单个的匹配字符串，只需要使用list的[n]就可以了。  

如果有分组，findall返回的仍然是list列表，不过是元组组成的列表而已。 

### 1.3 （替换）sub方法  

1. 第一步同上，抽象字符串（格式文本）输入`re.compile`做参数（`re.compile(r'Regex表达式')`，输出Regex对象   
2. 第二步，Regex对象调用sub方法，有两个参数，第二个参数同上，为查找池原始字符串，第一个参数为需要替换匹配结果的字符串。`xxRegex.sub(submsg, msg)`它的输出结果直接是替换后的字符串。

## 2. 正则表达式  

### 2.1 基础：分组

- ()：括号可以分组，用在正则表达式部分。**分组从1开始**，并非从0开始。在group方法中，参数为1则第1组，参数为2则第2组。参数为0或者空则为全部匹配文本。若要多个分组一起返回，则使用groups方法，返回值为元组。**区分全部匹配文本和全部分组，**前者是一个字符串，后者是一个元组。**被括号包围的部分才是分组。**  

### 2.2 组间关系  

- |：表示或者  
  
### 2.3 出现次数  

- ?：表示它前面的部分可选。如果是括号，则是这个分组可选，如果没有括号，则是这个字符可选。也就是**出现0次或1次。**  
- *：表示出现0次或多次。  
- +：表示出现1次或多次。**必须出现至少1次**。  
- {n}：重复n遍。如果是{m,n}，则重复m遍到n遍，这里m<n，重复遍数x为：m<=x<=n。m或n可以省略其中1个，逗号不省略，表示不限定最小值或最大值。**默认贪心，尽可能匹配最长的字符串。**如果想改变这个默认情况，即：希望匹配不贪心的，那么需要在{}后加上?。表达式为：`re.compile(r'(ha){3,5}?')`（以重复3遍到5遍的ha为例）

### 2.4 元素表达方式  

- \d：0-9任一数字字符  
- \D：除了0-9之外的其他任何字符。感觉是因为“非”很难表达，于是用了对应字母的大写来表示“非”。  
- \w：任何字母、数字、下划线字符（单词）  
- \W：除了字母数字下划线之外的字符。（非word）  
- \s：空格、制表符或换行符（空白字符）  
- \S：除了空格、制表符和换行符之外的任何字符。  
- . ：匹配除了换行之外的所有字符。`.*`可以表示除了换行之外的任意位字符。如果要不贪心，使用`(.*)?`。如果希望匹配结果中包含换行符呢？要给`re.compile`加参数：  `re.compile('.*',re.DOTALL)`  
- 不区分大小写，要给`re.compile`加参数：`re.compile('(\w)+',re.IGNORECASE)`，或者`re.compile('(\w)+',re.I)`   
- [x-x]：既可以是数字，也可以是字母，例如[0-9]和\d是一样的（也可以用(0|1|2|3|4|5|6|7|8|9)表示，不过这个就长多了），[a-z]表示任一小写字母。[]表示建立自己的字符分类。注意，不管[]里面写多少位，只匹配一个位置上的字符。[]中不需要写转义符\。好消息是：**[]可以使用非！用`^`表示。**例如：`[^aeiouAEIOU]`表达的是所有非元音字母的字符。   
- 复杂写法中，忽略正则表达式字符串中的空白符和注释，给`re.compile`传入第二个参数：`re.VERBOSE`  
- 三个都想作为第二个参数，就要使用|了。`re.compile(r'正则表达式',re.DOTALL|re.IGNORECASE|re.VERBOSE)`

### 2.5 限定被匹配文本在查找池的位置  

[正则 ?<= 和 ?= 用法 - whaozl - 博客园](https://www.cnblogs.com/whaozl/p/5462865.html)

- `^`表示开头，例如`^ae`表示整个查找池必须以ae开头。   
- `$`表示结尾，例如`ae$`表示整个查找池必须以ae结尾。  
- 匹配，捕获(存储)，?<=匹配开头，?=匹配结尾

> 
>  正则表达式：(?<=(href=")).{1,200}(?=(">))
>        解释：(?<=(href=")) 表示 匹配以(href=")开头的字符串，并且捕获(存储)到分组中
>                (?=(">)) 表示 匹配以(">)结尾的字符串，并且捕获(存储)到分组中



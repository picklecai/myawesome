# 正则表达式的用法  

别人的笔记：[可能是最好的正则表达式的教程笔记了吧... - 掘金](https://juejin.im/post/5b5db5b8e51d4519155720d2)  

[这可能是迄今最好的正则表达式语法测试教程学习笔记 - 神评(www.ishenping.com)](http://www.ishenping.com/ArtInfo/29302.html)

这里还有个在线测试工具：[在线正则表达式测试](http://tool.oschina.net/regex)

## 1. 匹配过程  

`import re`  

### 1.1 search方法  

从抽象字符串（匹配格式文本）到具体字符串（被匹配到的文本），一共经历三步🚶‍♀️🚶‍♀️🚶‍♀️：  
1. 抽象字符串（格式文本）输入`re.compile`做参数（`re.compile(r'Regex表达式')`，使用r是为了标识为原始字符串，方便\的出现。），输出Regex对象    
2. Regex对象调用search方法，使用查找池原始字符串做参数（`xxRegex.search(msg)`）。顺利的话，得到match对象，否则就是None（找不到对应格式的文本）  
3. Match对象调用group方法（`mo.group()`），无须参数，得到匹配的具体字符串。  

### 1.2 findall方法  

1. 第一步同上，抽象字符串（格式文本）输入`re.compile`做参数（`re.compile(r'Regex表达式')`，输出Regex对象   
2. 第二步， Regex对象调用findall方法，使用查找池原始字符串做参数（`xxRegex.findall(msg)`）。得到的不是match对象，而是匹配具体字符串组成的列表list。[matchtext1, matchtext2, ……，matchtextN]  
3. 要想得到单个的匹配字符串，只需要使用list的[n]就可以了。  

如果有分组，findall返回的仍然是list列表，不过是元组组成的列表而已。 

### 1.3 （替换）sub方法  

1. 第一步同上，抽象字符串（格式文本）输入`re.compile`做参数（`re.compile(r'Regex表达式')`，输出Regex对象   
2. 第二步，Regex对象调用sub方法，有两个参数，第二个参数同上，为查找池原始字符串，第一个参数为需要替换匹配结果的字符串。`xxRegex.sub(submsg, msg)`它的输出结果直接是替换后的字符串。

## 2. 正则表达式  

### 2.1 基础：分组

- ()：括号可以分组，用在正则表达式部分。**分组从1开始**，并非从0开始。在group方法中，参数为1则第1组，参数为2则第2组。参数为0或者空则为全部匹配文本。若要多个分组一起返回，则使用groups方法，返回值为元组。**区分全部匹配文本和全部分组，**前者是一个字符串，后者是一个元组。**被括号包围的部分才是分组。**  

### 2.2 组间关系  

- |：表示或者  
  
### 2.3 出现次数  

- ?：表示它前面的部分可选。如果是括号，则是这个分组可选，如果没有括号，则是这个字符可选。也就是**出现0次或1次。**  
- *：表示出现0次或多次。  
- +：表示出现1次或多次。**必须出现至少1次**。  
- {n}：重复n遍。如果是{m,n}，则重复m遍到n遍，这里m<n，重复遍数x为：m<=x<=n。m或n可以省略其中1个，逗号不省略，表示不限定最小值或最大值。**默认贪心，尽可能匹配最长的字符串。**如果想改变这个默认情况，即：希望匹配不贪心的，那么需要在{}后加上?。表达式为：`re.compile(r'(ha){3,5}?')`（以重复3遍到5遍的ha为例）

### 2.4 元素表达方式  

- \d：0-9任一数字字符  
- \D：除了0-9之外的其他任何字符。感觉是因为“非”很难表达，于是用了对应字母的大写来表示“非”。  
- \w：任何字母、数字、下划线字符（单词）  
- \W：除了字母数字下划线之外的字符。（非word）  
- \s：空格、制表符或换行符（空白字符）  
- \S：除了空格、制表符和换行符之外的任何字符。  
- . ：匹配除了换行之外的所有字符。`.*`可以表示除了换行之外的任意位字符。如果要不贪心，使用`(.*)?`。如果希望匹配结果中包含换行符呢？要给`re.compile`加参数：  `re.compile('.*',re.DOTALL)`  
- 不区分大小写，要给`re.compile`加参数：`re.compile('(\w)+',re.IGNORECASE)`，或者`re.compile('(\w)+',re.I)`   
- [x-x]：既可以是数字，也可以是字母，例如[0-9]和\d是一样的（也可以用(0|1|2|3|4|5|6|7|8|9)表示，不过这个就长多了），[a-z]表示任一小写字母。[]表示建立自己的字符分类。注意，不管[]里面写多少位，只匹配一个位置上的字符。[]中不需要写转义符\。好消息是：**[]可以使用非！用`^`表示。**例如：`[^aeiouAEIOU]`表达的是所有非元音字母的字符。   
- 复杂写法中，忽略正则表达式字符串中的空白符和注释，给`re.compile`传入第二个参数：`re.VERBOSE`  
- 三个都想作为第二个参数，就要使用|了。`re.compile(r'正则表达式',re.DOTALL|re.IGNORECASE|re.VERBOSE)`

### 2.5 限定被匹配文本在查找池的位置  

[正则 ?<= 和 ?= 用法 - whaozl - 博客园](https://www.cnblogs.com/whaozl/p/5462865.html)

- `^`表示开头，例如`^ae`表示整个查找池必须以ae开头。   
- `$`表示结尾，例如`ae$`表示整个查找池必须以ae结尾。  
- 匹配，捕获(存储)，?<=匹配开头，?=匹配结尾

> 
>  正则表达式：(?<=(href=")).{1,200}(?=(">))
>        解释：(?<=(href=")) 表示 匹配以(href=")开头的字符串，并且捕获(存储)到分组中
>                (?=(">)) 表示 匹配以(">)结尾的字符串，并且捕获(存储)到分组中


# 《精通正则表达式》  

[Jeffrey Friedl's Web Sites](http://regex.info/)，一本号称精通的书，还是余晟翻译的。几年前我就打算读，并读了几页纸，此后一直躺在豆瓣‘在读’列表中，现在又想起来读着试试看。

## egrep

[哪里可以获得egrep](http://regex.info/egrep.html)

在mac下运行`egrep --version`，是有输出的：  

```
egrep (BSD grep) 2.5.1-FreeBSD
```
不是作者说的GNU egrep，而是FreeBSD的。

[Macos下如何实现grep的非贪婪模式 | Recording](https://www.jibing57.com/2018/02/09/non-greedy-match-in-grep-on-macos/)

> 
> 在Terminal中敲击man egrep, 在man page的Description中可以看到有如下一行描述
>  ```
grep is used for simple patterns and basic regular expressions (BREs); 
egrep can handle extended regular expressions (EREs).
```
> 
> 可以看到Mac默认的grep只支持基本政策表达式，而egrep支持扩展正则表达式
>

### mac下安装egrep：

还是上面这个地址：  

> 不覆盖系统自带的grep，通过~/.bashrc alias的方式来实现

`brew install grep`

> 此时，brew安装的GNU grep安装路径为/usr/local/bin/ggrep。注意是ggrep，而不是grep。
> 再通过alias的方式让shell在运行grep的时候运行ggrep, 可以达到同样的效果

`echo "alias grep='ggrep'" >> ~/.bashrc`

这句话没有起作用。仍然要用ggrep。



## 新知  

`\<`和`\>`，说是单词版读开头和结尾（`^$`），但是在python3中，试验没有成功。  
\1代表第一组，那个间谍替换名字的案例就是用了这一点。也可以用来找重复，只要用括号划分出组来。  

可以在程序要求用户输入时使用正则表达式来验证输入是否有问题，类似那天用的isdecimal函数。   

`()`表示捕获和分组，`(?:)`表示只分组不捕获，这个在python中也是支持的。

`(?=)`表示当前位置的右边能匹配， `(?<=)`表示当前位置的左边能匹配。

`(?!)`表示当前位置的右边不能匹配， `(?<!)`表示当前位置的左边不能匹配。

python中，**逆序环视只能匹配固定长度的文本**。

HTML编码：
```
&: &amp
<: &lt
>: &gt
```

字符串形式和逻辑行形式，例如把一整个文件的内容读入字符串，逻辑行就是其中的分行。

命名捕获：`(?P<name>)`，给捕获内容命名。例如：
  
```
\b(?P<Area>\d\d\d)-(?P<Exch>\d\d\d)-(?P<Num>\d\d\d\d)\b
```

这个也是电话号码，给各部分命名了，区号就叫Area，在程序中使用是这样的：`RegexObj.group('Area)`，本来可能是用`group(0)`来表示的。在正则表达式内部使用时这样的：`(?P=Area)`

### **固化分组**：`(?>...)`

不太明白。

`(?>.*?)`不代表任何字符。???

## 判断是否传统型NFA  

```
import re

regexN = re.compile(r'nfa|nfa not')
mo = regexN.search('nfa not')
mo.group()
```
结果是'nfa'就是传统型NFA，结果是'nfa not'就是POSIX NFA 或 DFA。


## 强口令测试  

这个花了很久时间，一开始以为写对了，结果一测试，完全不对。完全不对的这个版本：  

```
strongPwRegex = re.compile(r'(([A-Z]+[a-z]+(\d)+)|([A-Z]+(\d)+[a-z]+)|([a-z]+[A-Z]+(\d)+)|((\d)+[A-Z]+[a-z]+)|([a-z]+(\d)+[A-Z]+)|((\d)+[a-z]+[A-Z]+)){2,}([a-zA-Z\d]){2,}')
```
强令可能的组合必须再来一遍以此来控制位数，实际情况是这种太特殊了，无法普适。

后来写一个明知道不对的： 

```
strongPwRegex = re.compile(r'[A-Za-z\d]{8,}')

```
这个别说强口令了，连续相同字母都可以通过，唯一的好处是8位很好控制。

三改五改，又出来一个：  

```
strongPwRegex = re.compile(r'(([a-zA-Z\d]*)(([A-Z]+[a-z]+[\d]+)|([A-Z]+[\d]+[a-z]+)|([a-z]+[A-Z]+[\d]+)|([\d]+[A-Z]+[a-z]+)|([a-z]+[\d]+[A-Z]+)|([\d]+[a-z]+[A-Z]+)))+[a-zA-Z\d]*')
```
它的好处是大小写字母和数字三者必须要有一个，坏处就是没用上面那个啥用没有的8位控制。只要3位就能通过测试。

再有其他的，都不如这三个版本了。实在不明白正则表达式怎么控制位数，第二个版本`{8,}`，那怎么控制大小写和数字都有呢，就是上面第三个版本。怎么两者结合起来呢？？？

于是去搜了一下控制位数，看到有人用好几段来写，那显然不是出题人的本意。想着以江湖盛传的强大，不应该需要第二句话。

看到有个测试工具[正则表达式在线测试 | 菜鸟工具](https://c.runoob.com/front-end/854)，把自己写的输入进去，无聊之余，往下翻翻，却发现了答案：  

```
strongPwRegex = re.compile(r'(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\d]{8,}')
```
很简单的一句话有木有？  

为什么当前位置右边匹配任意字符加数字、任意字符加小写字母、任意字符加大写字母，能保证这三个全部都有呢？试了一下，去掉`.*`就不管用了。也不明白这三个当前位置右边匹配，之间是什么关系？或者吗？  

心凉凉的，没想到看到答案也不不懂。

[密码强度的正则表达式（JavaScript）总结 - 毛三十 - 博客园](https://www.cnblogs.com/ifat3/p/8534525.html) 这个人对这种写法做了解释，感觉语焉不详。

[正则--强密码校验 - Switch的博客 - CSDN博客](https://blog.csdn.net/q547550831/article/details/70550526)

这个人解释得详细一些：  

```
passwordReg = re.compile(r'''
        (?=^.{8,}$)     # 八位数及以上
        ((?=.*\d+))     # 至少一位数字
        (?![.\n])       # 没有换行符
        (?=.*[A-Z])     # 大写任意个
        (?=.*[a-z]).*$  # 小写任意个
    ''', re.VERBOSE)

```



还有一个当前位置右边不能匹配：  

```
strongPwRegex = re.compile(r'^(?!\d+$)(?![a-z]+$)(?![A-Z]+$)[a-zA-Z\d]{8,}$')
```
发现这个不能检测出缺少大写字母的。

[使用正则表达式，确保传入的口令是强口令 - rongliner的博客 - CSDN博客](https://blog.csdn.net/rongliner/article/details/71574108)

这兄弟牛。直接分步骤写了。看上去他也是在做这一题。

通过重新看第60页（pdf文本第86页）的内容，理解了上面两种强口令写法。  

一个是找这样的大小写字母或数字`[a-zA-Z\d]`，它左侧的当前位置右边`(?=)`，有任意字符加数字、加小写字母、加大写字母。这个位置其实就是开头，并不是每一个位置右边都要有。

另一个写法是：当前位置右侧不能是纯数字，不能是纯小写字母，不能是纯大写字母。所以后一种写法无法检测出大小写字母缺一种的情况。

前半截代表位置特征，后半截代表内容特征。最后再约束一下长度。

## DFA与NFA  

怪不得DFA更快，原来它从目标文本出发来看正则表达式。而NFA则从正则表达式出发去看文本。

注：这个作者说的‘匹配优先’和‘忽略优先’分别对应着‘贪心算法’和‘非贪心算法’

